/*
 * generated by Xtext 2.25.0
 */
package mde.iot.ucm4iot.serializer;

import com.google.inject.Inject;
import java.util.Set;
import mde.iot.ucm4iot.services.Ucm4iotGrammarAccess;
import mde.iot.ucm4iot.ucm4iot.AlternateBlock;
import mde.iot.ucm4iot.ucm4iot.ConditionControlStep;
import mde.iot.ucm4iot.ucm4iot.ContextExceptionMapping;
import mde.iot.ucm4iot.ucm4iot.DeviceActor;
import mde.iot.ucm4iot.ucm4iot.EnvironmentException;
import mde.iot.ucm4iot.ucm4iot.ExceptionalBlock;
import mde.iot.ucm4iot.ucm4iot.ExceptionalUseCase;
import mde.iot.ucm4iot.ucm4iot.Extensions;
import mde.iot.ucm4iot.ucm4iot.HandlerUseCase;
import mde.iot.ucm4iot.ucm4iot.HardwareException;
import mde.iot.ucm4iot.ucm4iot.HumanActor;
import mde.iot.ucm4iot.ucm4iot.InteractionStep;
import mde.iot.ucm4iot.ucm4iot.InvocationStep;
import mde.iot.ucm4iot.ucm4iot.IoTUseCaseModel;
import mde.iot.ucm4iot.ucm4iot.MainScenario;
import mde.iot.ucm4iot.ucm4iot.NetworkException;
import mde.iot.ucm4iot.ucm4iot.OutcomeContinues;
import mde.iot.ucm4iot.ucm4iot.OutcomeEnds;
import mde.iot.ucm4iot.ucm4iot.PhysicalEntityActor;
import mde.iot.ucm4iot.ucm4iot.PrimaryActor;
import mde.iot.ucm4iot.ucm4iot.SecondaryActor;
import mde.iot.ucm4iot.ucm4iot.SoftwareActor;
import mde.iot.ucm4iot.ucm4iot.SoftwareException;
import mde.iot.ucm4iot.ucm4iot.Ucm4iotPackage;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class Ucm4iotSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private Ucm4iotGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Ucm4iotPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Ucm4iotPackage.ALTERNATE_BLOCK:
				sequence_AlternateBlock(context, (AlternateBlock) semanticObject); 
				return; 
			case Ucm4iotPackage.CONDITION_CONTROL_STEP:
				sequence_ConditionControlStep(context, (ConditionControlStep) semanticObject); 
				return; 
			case Ucm4iotPackage.CONTEXT_EXCEPTION_MAPPING:
				sequence_ContextExceptionMapping(context, (ContextExceptionMapping) semanticObject); 
				return; 
			case Ucm4iotPackage.DEVICE_ACTOR:
				sequence_DeviceActor(context, (DeviceActor) semanticObject); 
				return; 
			case Ucm4iotPackage.ENVIRONMENT_EXCEPTION:
				sequence_EnvironmentException(context, (EnvironmentException) semanticObject); 
				return; 
			case Ucm4iotPackage.EXCEPTIONAL_BLOCK:
				sequence_ExceptionalBlock(context, (ExceptionalBlock) semanticObject); 
				return; 
			case Ucm4iotPackage.EXCEPTIONAL_USE_CASE:
				if (rule == grammarAccess.getExceptionalUseCaseRule()) {
					sequence_ExceptionalUseCase(context, (ExceptionalUseCase) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUseCaseRule()) {
					sequence_ExceptionalUseCase_UseCase(context, (ExceptionalUseCase) semanticObject); 
					return; 
				}
				else break;
			case Ucm4iotPackage.EXTENSIONS:
				sequence_Extensions(context, (Extensions) semanticObject); 
				return; 
			case Ucm4iotPackage.HANDLER_USE_CASE:
				if (rule == grammarAccess.getHandlerUseCaseRule()) {
					sequence_HandlerUseCase(context, (HandlerUseCase) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUseCaseRule()) {
					sequence_HandlerUseCase_UseCase(context, (HandlerUseCase) semanticObject); 
					return; 
				}
				else break;
			case Ucm4iotPackage.HARDWARE_EXCEPTION:
				sequence_HardwareException(context, (HardwareException) semanticObject); 
				return; 
			case Ucm4iotPackage.HUMAN_ACTOR:
				sequence_HumanActor(context, (HumanActor) semanticObject); 
				return; 
			case Ucm4iotPackage.INTERACTION_STEP:
				sequence_InteractionStep(context, (InteractionStep) semanticObject); 
				return; 
			case Ucm4iotPackage.INVOCATION_STEP:
				sequence_InvocationStep(context, (InvocationStep) semanticObject); 
				return; 
			case Ucm4iotPackage.IO_TUSE_CASE_MODEL:
				sequence_IoTUseCaseModel(context, (IoTUseCaseModel) semanticObject); 
				return; 
			case Ucm4iotPackage.MAIN_SCENARIO:
				sequence_MainScenario(context, (MainScenario) semanticObject); 
				return; 
			case Ucm4iotPackage.NETWORK_EXCEPTION:
				sequence_NetworkException(context, (NetworkException) semanticObject); 
				return; 
			case Ucm4iotPackage.OUTCOME_CONTINUES:
				sequence_OutcomeContinues(context, (OutcomeContinues) semanticObject); 
				return; 
			case Ucm4iotPackage.OUTCOME_ENDS:
				sequence_OutcomeEnds(context, (OutcomeEnds) semanticObject); 
				return; 
			case Ucm4iotPackage.PHYSICAL_ENTITY_ACTOR:
				sequence_PhysicalEntityActor(context, (PhysicalEntityActor) semanticObject); 
				return; 
			case Ucm4iotPackage.PRIMARY_ACTOR:
				sequence_PrimaryActor(context, (PrimaryActor) semanticObject); 
				return; 
			case Ucm4iotPackage.SECONDARY_ACTOR:
				sequence_SecondaryActor(context, (SecondaryActor) semanticObject); 
				return; 
			case Ucm4iotPackage.SOFTWARE_ACTOR:
				sequence_SoftwareActor(context, (SoftwareActor) semanticObject); 
				return; 
			case Ucm4iotPackage.SOFTWARE_EXCEPTION:
				sequence_SoftwareException(context, (SoftwareException) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ExtensionBlock returns AlternateBlock
	 *     AlternateBlock returns AlternateBlock
	 *
	 * Constraint:
	 *     (
	 *         (refStep=[Step|StepNumber] | (hasRangedRef?='(' refStep=[Step|StepNumber] endRefStep=[Step|StepNumber])) 
	 *         steps+=Step+ 
	 *         (outcome=Outcome | blocks+=ExtensionBlock+)
	 *     )
	 */
	protected void sequence_AlternateBlock(ISerializationContext context, AlternateBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Step returns ConditionControlStep
	 *     ConditionControlStep returns ConditionControlStep
	 *
	 * Constraint:
	 *     (description=STRING | ignoreDescription?=IGNORE_STRING)
	 */
	protected void sequence_ConditionControlStep(ISerializationContext context, ConditionControlStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContextExceptionMapping returns ContextExceptionMapping
	 *
	 * Constraint:
	 *     (context=[UseCase|ID] exception=[Exception|ID])
	 */
	protected void sequence_ContextExceptionMapping(ISerializationContext context, ContextExceptionMapping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ucm4iotPackage.Literals.CONTEXT_EXCEPTION_MAPPING__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ucm4iotPackage.Literals.CONTEXT_EXCEPTION_MAPPING__CONTEXT));
			if (transientValues.isValueTransient(semanticObject, Ucm4iotPackage.Literals.CONTEXT_EXCEPTION_MAPPING__EXCEPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ucm4iotPackage.Literals.CONTEXT_EXCEPTION_MAPPING__EXCEPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContextExceptionMappingAccess().getContextUseCaseIDTerminalRuleCall_0_0_1(), semanticObject.eGet(Ucm4iotPackage.Literals.CONTEXT_EXCEPTION_MAPPING__CONTEXT, false));
		feeder.accept(grammarAccess.getContextExceptionMappingAccess().getExceptionExceptionIDTerminalRuleCall_4_0_1(), semanticObject.eGet(Ucm4iotPackage.Literals.CONTEXT_EXCEPTION_MAPPING__EXCEPTION, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actor returns DeviceActor
	 *     SecondaryActor returns DeviceActor
	 *     DeviceActor returns DeviceActor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DeviceActor(ISerializationContext context, DeviceActor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ucm4iotPackage.Literals.ACTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ucm4iotPackage.Literals.ACTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeviceActorAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exception returns EnvironmentException
	 *     EnvironmentException returns EnvironmentException
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnvironmentException(ISerializationContext context, EnvironmentException semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ucm4iotPackage.Literals.EXCEPTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ucm4iotPackage.Literals.EXCEPTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvironmentExceptionAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExtensionBlock returns ExceptionalBlock
	 *     ExceptionalBlock returns ExceptionalBlock
	 *
	 * Constraint:
	 *     (
	 *         (refStep=[Step|StepNumber] | (hasRangedRef?='(' refStep=[Step|StepNumber] endRefStep=[Step|StepNumber])) 
	 *         steps+=Step+ 
	 *         (outcome=Outcome | blocks+=ExtensionBlock+)
	 *     )
	 */
	protected void sequence_ExceptionalBlock(ISerializationContext context, ExceptionalBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExceptionalUseCase returns ExceptionalUseCase
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             (
	 *                 scope=ID | 
	 *                 intent=STRING | 
	 *                 level=Level | 
	 *                 multiplicity=STRING | 
	 *                 precondition=STRING | 
	 *                 postcondition=STRING | 
	 *                 primaryActor=PrimaryActor
	 *             )? 
	 *             (facilitatorActors+=SecondaryActor facilitatorActors+=SecondaryActor*)? 
	 *             (secondaryActors+=SecondaryActor secondaryActors+=SecondaryActor*)?
	 *         )+
	 *     )
	 */
	protected void sequence_ExceptionalUseCase(ISerializationContext context, ExceptionalUseCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UseCase returns ExceptionalUseCase
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             (
	 *                 scope=ID | 
	 *                 intent=STRING | 
	 *                 level=Level | 
	 *                 multiplicity=STRING | 
	 *                 precondition=STRING | 
	 *                 postcondition=STRING | 
	 *                 primaryActor=PrimaryActor
	 *             )? 
	 *             (facilitatorActors+=SecondaryActor facilitatorActors+=SecondaryActor*)? 
	 *             (secondaryActors+=SecondaryActor secondaryActors+=SecondaryActor*)?
	 *         )+ 
	 *         main=MainScenario 
	 *         extensions=Extensions?
	 *     )
	 */
	protected void sequence_ExceptionalUseCase_UseCase(ISerializationContext context, ExceptionalUseCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Extensions returns Extensions
	 *
	 * Constraint:
	 *     blocks+=ExtensionBlock+
	 */
	protected void sequence_Extensions(ISerializationContext context, Extensions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HandlerUseCase returns HandlerUseCase
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             (
	 *                 scope=ID | 
	 *                 intent=STRING | 
	 *                 level=Level | 
	 *                 multiplicity=STRING | 
	 *                 precondition=STRING | 
	 *                 postcondition=STRING | 
	 *                 primaryActor=PrimaryActor | 
	 *                 handlerClass=ID
	 *             )? 
	 *             (contextExceptions+=ContextExceptionMapping contextExceptions+=ContextExceptionMapping*)? 
	 *             (facilitatorActors+=SecondaryActor facilitatorActors+=SecondaryActor*)? 
	 *             (secondaryActors+=SecondaryActor secondaryActors+=SecondaryActor*)?
	 *         )+
	 *     )
	 */
	protected void sequence_HandlerUseCase(ISerializationContext context, HandlerUseCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UseCase returns HandlerUseCase
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             (
	 *                 scope=ID | 
	 *                 intent=STRING | 
	 *                 level=Level | 
	 *                 multiplicity=STRING | 
	 *                 precondition=STRING | 
	 *                 postcondition=STRING | 
	 *                 primaryActor=PrimaryActor | 
	 *                 handlerClass=ID
	 *             )? 
	 *             (contextExceptions+=ContextExceptionMapping contextExceptions+=ContextExceptionMapping*)? 
	 *             (secondaryActors+=SecondaryActor secondaryActors+=SecondaryActor*)? 
	 *             (facilitatorActors+=SecondaryActor facilitatorActors+=SecondaryActor*)?
	 *         )+ 
	 *         main=MainScenario 
	 *         extensions=Extensions?
	 *     )
	 */
	protected void sequence_HandlerUseCase_UseCase(ISerializationContext context, HandlerUseCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exception returns HardwareException
	 *     HardwareException returns HardwareException
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_HardwareException(ISerializationContext context, HardwareException semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ucm4iotPackage.Literals.EXCEPTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ucm4iotPackage.Literals.EXCEPTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHardwareExceptionAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actor returns HumanActor
	 *     PrimaryActor returns HumanActor
	 *     SecondaryActor returns HumanActor
	 *     HumanActor returns HumanActor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_HumanActor(ISerializationContext context, HumanActor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ucm4iotPackage.Literals.ACTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ucm4iotPackage.Literals.ACTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHumanActorAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Step returns InteractionStep
	 *     InteractionStep returns InteractionStep
	 *
	 * Constraint:
	 *     (stepNumber=StepNumber exception=Exception? (description=STRING | ignoreDescription?=IGNORE_STRING))
	 */
	protected void sequence_InteractionStep(ISerializationContext context, InteractionStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Step returns InvocationStep
	 *     InvocationStep returns InvocationStep
	 *
	 * Constraint:
	 *     (stepNumber=StepNumber invokedUseCase=[UseCase|ID] (description=STRING | ignoreDescription?=IGNORE_STRING))
	 */
	protected void sequence_InvocationStep(ISerializationContext context, InvocationStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IoTUseCaseModel returns IoTUseCaseModel
	 *
	 * Constraint:
	 *     (standardMode?='on'? useCases+=UseCase*)
	 */
	protected void sequence_IoTUseCaseModel(ISerializationContext context, IoTUseCaseModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MainScenario returns MainScenario
	 *
	 * Constraint:
	 *     (steps+=Step+ outcome=OutcomeEnds)
	 */
	protected void sequence_MainScenario(ISerializationContext context, MainScenario semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Exception returns NetworkException
	 *     NetworkException returns NetworkException
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_NetworkException(ISerializationContext context, NetworkException semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ucm4iotPackage.Literals.EXCEPTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ucm4iotPackage.Literals.EXCEPTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNetworkExceptionAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Outcome returns OutcomeContinues
	 *     OutcomeContinues returns OutcomeContinues
	 *
	 * Constraint:
	 *     step=[Step|StepNumber]
	 */
	protected void sequence_OutcomeContinues(ISerializationContext context, OutcomeContinues semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ucm4iotPackage.Literals.OUTCOME_CONTINUES__STEP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ucm4iotPackage.Literals.OUTCOME_CONTINUES__STEP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutcomeContinuesAccess().getStepStepStepNumberParserRuleCall_2_0_1(), semanticObject.eGet(Ucm4iotPackage.Literals.OUTCOME_CONTINUES__STEP, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Outcome returns OutcomeEnds
	 *     OutcomeEnds returns OutcomeEnds
	 *
	 * Constraint:
	 *     type=OutcomeEndings
	 */
	protected void sequence_OutcomeEnds(ISerializationContext context, OutcomeEnds semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ucm4iotPackage.Literals.OUTCOME_ENDS__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ucm4iotPackage.Literals.OUTCOME_ENDS__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutcomeEndsAccess().getTypeOutcomeEndingsEnumRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actor returns PhysicalEntityActor
	 *     SecondaryActor returns PhysicalEntityActor
	 *     PhysicalEntityActor returns PhysicalEntityActor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_PhysicalEntityActor(ISerializationContext context, PhysicalEntityActor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ucm4iotPackage.Literals.ACTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ucm4iotPackage.Literals.ACTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPhysicalEntityActorAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actor returns PrimaryActor
	 *     PrimaryActor returns PrimaryActor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_PrimaryActor(ISerializationContext context, PrimaryActor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ucm4iotPackage.Literals.ACTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ucm4iotPackage.Literals.ACTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryActorAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actor returns SecondaryActor
	 *     SecondaryActor returns SecondaryActor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SecondaryActor(ISerializationContext context, SecondaryActor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ucm4iotPackage.Literals.ACTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ucm4iotPackage.Literals.ACTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSecondaryActorAccess().getNameIDTerminalRuleCall_4_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Actor returns SoftwareActor
	 *     PrimaryActor returns SoftwareActor
	 *     SecondaryActor returns SoftwareActor
	 *     SoftwareActor returns SoftwareActor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SoftwareActor(ISerializationContext context, SoftwareActor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ucm4iotPackage.Literals.ACTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ucm4iotPackage.Literals.ACTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSoftwareActorAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Exception returns SoftwareException
	 *     SoftwareException returns SoftwareException
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SoftwareException(ISerializationContext context, SoftwareException semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ucm4iotPackage.Literals.EXCEPTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ucm4iotPackage.Literals.EXCEPTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSoftwareExceptionAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
